---
title: "`data.table.threads` - find the best thread count!"
author: "Anirban Chetia"
date: "2024-10-21"
categories: [developer, benchmarks, speedup, parallelization]
image: ""
draft: false
---

## [`data.table.threads`](https://github.com/Anirban166/data.table.threads)

When working with large datasets, leveraging system resources like multiple CPU threads for shared-memory parallelization can significantly reduce computation time. However, it isnâ€™t straightforward to determine the optimal thread count to obtain the lowest runtime for an operation, or on the other hand, the number of threads required for efficient speedup scaling.

In an R package like `data.table` where parallelization is extensively utilized (or by most operations), it can be convenient to automatically figure out the number of threads to use for achieving the fastest execution time in the case of a particular routine, without the user needing to rely on ad-hoc experiments. Likewise, it would be handy if the user could set the thread count keeping in mind maximum (or a user-defined ratio) scalability in terms of the speedup obtained, which otherwise can be tricky or time-consuming to figure out manually.

This is where `data.table.threads` comes in - A package designed to assist in finding the most suitable thread count for the various parallelized operations within `data.table`.

## Key features

`findOptimalThreadCount(rowCount, columnCount, ...)`, the main user-facing function, runs a set of predefined benchmarks for each applicable function across varying thread counts (iteratively from one to the highest number available as per the user's system) and involves computation to find the optimal/ideal speedup and thread count for each function. It returns a `data.table` object of a custom class (`print` and `plot` methods have been provided), which contains the optimal thread count for each function. It also provides plot data (consisting of speedup trends and key points) as attributes.

Printing this object would enlist the fastest median runtime (in milliseconds) along with the thread count that achieved it for each function.

Plotting the object would generate a plot that shows the ideal and measured speedup trends for each benchmarked `data.table` function.

If the user wants to factor in a specified speedup efficiency, they can use the function `addRecommendedEfficiency` to add a speedup line (with a slope configured by input argument `efficiencyFactor`; default value is 0.5, or 50% efficiency) along with a point representing the recommended thread count which stems from the highest intersection between this line (of specified thread-use efficiency) and measured speedup data for each function.

Here is an example:
```{r}
library(data.table.threads)

(benchmarks <- data.table.threads::findOptimalThreadCount(1e7, 10, verbose = FALSE))
plot(benchmarks)
benchmarks_r <- addRecommendedEfficiency(benchmarks, recommendedEfficiency = 0.6)
plot(benchmarks_r)
```

In order to set the thread count based on observed results for a user-specified function and speedup efficiency value, the `setThreadCount(benchmarkData, functionName, efficiencyFactor)` function can then be used:
```{r}
setThreadCount(benchmarks, functionName = "forder", efficiencyFactor = 1)
```

When using `findOptimalThreadCount()`, users can also replace the predefined benchmarks with their own expressions by providing a list of custom functions as the `benchmarksList` argument, enabling evaluation tailored to their specific use cases. On top of that, they can also specify their own `data.table` construct via the `customDT` argument to have the functions they define operate on it instead of the default matrix-based `data.table` that makes use of `rowCount` and `colCount`.

For instance, here is an example:
```{r}
# Derived from https://github.com/Rdatatable/data.table/issues/4294
NN = 1e5
DT = data.table(grp1 = as.character(rep(1:(NN / 4), each = 4)),
                grp2 = sample(5000L, NN, TRUE),
                V = rpois(NN, 10))
findOptimalThreadCount(benchmarksList = list(test4294 = function(dt) dt[, log(sum(V)), by = grp1]), customDT = DT)
# Optimal performance is observed for a single thread in this case since the code includes creation of many small groups where the computation for each of them is relatively lightweight to see improvement in performance outweighing the overhead from multi-threading.
```
