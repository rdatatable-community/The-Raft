{
  "hash": "92646c108a452ae59494a0d70c19158f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Benchmarking memory usage in R\"\nauthor: \"Jan Gorecki\"\ndate: \"2025-07-14\"\ncategories: [performance, benchmarking, developer]\nimage: \"benchmark.jpeg\"\ndraft: false\nexecute:\n  eval: false\n---\n\n\n\n\n# Benchmarking memory usage in R\n\nProfiling memory in R has never been a trivial task.\\\nIn this post, I would like to emphasize that currently popular methods are quite inaccurate and should therefore be used with caution. More importantly, they should not be used for drawing conclusions about the actual memory usage of R functions.\n\nThe root cause of the inaccuracy with many memory profiling tools in R is that they measure memory allocated by R (including R's C code). They do not take into account memory allocated using C.\n\n## Memory allocation in R\n\nFollowing example should make it very clear.\n\nBelow R chunk is the content of `memtest.R` file.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncode = \"\n  int nx = LENGTH(x);\n  double *y = (double*)(\n    LOGICAL(r_alloc)[0] ?\n      R_alloc(nx, sizeof(*y)) : // allocated by R's C\n      malloc(nx * sizeof(*y))   // allocated by C\n  );\n  double *xp = REAL(x);\n  // populate y\n  for (int i=0; i<nx; i++)\n    y[i] = xp[i];\n  // do something with y\n  for (int i=1; i<nx; i++)\n    y[i] = y[i-1]+y[i];\n  // sum double array to ensure compiler wont optimize it away\n  double sum = 0.0;\n  for (int i=0; i<nx; i++)\n    sum += y[i];\n  SEXP res = PROTECT(Rf_allocVector(REALSXP, 1));\n  REAL(res)[0] = sum;\n  if (!LOGICAL(r_alloc)[0])\n    free(y);\n  UNPROTECT(1);\n  return res;\n\"\nfunx = inline::cfunction(signature(x=\"numeric\", r_alloc=\"logical\"), code, language=\"C\")\nset.seed(108)\nx = rnorm(1e8)\n```\n:::\n\n\n\n\n## Check equal\n\nFirst, we will ensure that the results are the same, regardless of whether we allocate temporary working memory using R or C:\n\n\n\n\n::: {.cell}\n\n```{.sh .cell-code}\nRscript -e 'source(\"memtest.R\"); funx(x, r_alloc=TRUE)'\n#[1] 1.160649e+12\nRscript -e 'source(\"memtest.R\"); funx(x, r_alloc=FALSE)'\n#[1] 1.160649e+12\n```\n:::\n\n\n\n\n## Memory benchmark using `bench`\n\nNext, we will use the currently most popular package for profiling memory, `bench`:\n\n\n\n\n::: {.cell}\n\n```{.sh .cell-code}\nRscript -e 'source(\"memtest.R\"); bench::mark(funx(x, r_alloc=TRUE))'\n## A tibble: 1 × 13\n#  expression      min median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time\n#  <bch:expr>    <bch> <bch:>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm>\n#1 funx(x, r_al… 577ms  577ms      1.73     763MB     1.73     1     1      577ms\nRscript -e 'source(\"memtest.R\"); bench::mark(funx(x, r_alloc=FALSE))'\n## A tibble: 1 × 13\n#  expression      min median `itr/sec` mem_alloc `gc/sec` n_itr  n_gc total_time\n#  <bch:expr>    <bch> <bch:>     <dbl> <bch:byt>    <dbl> <int> <dbl>   <bch:tm>\n#1 funx(x, r_al… 589ms  589ms      1.70        0B        0     1     0      589ms\n```\n:::\n\n\n\n\nAs we can see in the output of `mark` function, `mem_alloc` is reported to be 0B when we use `malloc`, while for `R_alloc` it reports 763MB. The difference we observe here should serve as a warning. It is because `bench::mark` tracks memory allocations managed by R's memory allocator and doesn't inherently account for memory allocated directly through C functions like `malloc` or `calloc`. If one intends to use the `mark` function to draw conclusions about memory usage, it's crucial to also examine the source code of the function being benchmarked.\n\nIt is worth to note that `?mark` explains this issue:\n\n> `mem_alloc` - `bench_bytes` Total amount of memory allocated by R while running the expression. Memory allocated outside the R heap, e.g. by `malloc()` or `new` directly is not tracked, take care to avoid misinterpreting the results if running code that may do this.\n\nUnfortunately, people are not aware of it and often publish memory usage benchmarks believing they are accurate.\n\n## Memory benchmark using `cgmemtime`\n\nLastly, we will use an external process to measure memory, [cgmemtime](https://github.com/gsauthof/cgmemtime), proposed by Matt Dowle in 2014 during his work on [2B rows data.frame grouping benchmark](https://github.com/Rdatatable/data.table/wiki/Benchmarks-:-Grouping).\n\n> `cgmemtime` measures the high-water RSS+CACHE memory usage of a process and its descendant processes.\n\n\n\n\n::: {.cell}\n\n```{.sh .cell-code}\n./cgmemtime Rscript -e 'source(\"memtest.R\"); funx(x, r_alloc=TRUE)'\n#child_RSS_high:    1641808 KiB\n#group_mem_high:    1626264 KiB\n./cgmemtime Rscript -e 'source(\"memtest.R\"); funx(x, r_alloc=FALSE)'\n#child_RSS_high:    1641096 KiB\n#group_mem_high:    1625820 KiB\n```\n:::\n\n\n\n\nWhile `cgmemtime` will report very accurate memory usage statistics, it cannot directly measure the memory usage of an individual function call in isolation as it tracks the memory footprint of the entire process (and its child processes).\\\nTo estimate the memory usage of the `funx()` call in this simple example, we can first measure the R process without calling `funx()`.\n\n\n\n\n::: {.cell}\n\n```{.sh .cell-code}\n./cgmemtime Rscript -e 'source(\"memtest.R\");'\n#child_RSS_high:     860884 KiB\n#group_mem_high:     843844 KiB\n```\n:::\n\n\n\n\nAnd then subtract this baseline from the memory usage when `funx()` is executed:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(1641096-860884)/1024\n#[1] 761.9258\n```\n:::\n\n\n\n\n## Thank you\n\nI hope this post will help people to be a bit more skeptical when reading R's memory benchmarks.\n\n```         \nR version 4.5.0 (2025-04-11)\nPlatform: x86_64-redhat-linux-gnu\nRunning under: Fedora Linux 42 (Workstation Edition)\n\nMatrix products: default\nBLAS/LAPACK: FlexiBLAS OPENBLAS-OPENMP;  LAPACK version 3.12.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] bench_1.1.4   inline_0.3.21\n\nloaded via a namespace (and not attached):\n[1] compiler_4.5.0  cli_3.6.4       pillar_1.10.2   glue_1.8.0     \n[5] vctrs_0.6.5     lifecycle_1.0.4 rlang_1.1.6   \n```\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}